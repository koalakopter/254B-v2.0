#pragma config(Sensor, in1,    armShaft,       sensorPotentiometer)
#pragma config(Sensor, dgtl1,  rightshaft,     sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftshaft,      sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  MemeLight,      sensorLEDtoVCC)
#pragma config(Motor,  port1,           RearRight,     tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           FrontRight,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           FrontLeft,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           LTopArm,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           LBotArm,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           RTopArm,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           RBotArm,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           Fork,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           Winch,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          RearLeft,      tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"
void drive(int xaxis, int yaxis, int turning)
{
	int forwardDeadzone = 15;

	if (yaxis > 127 - forwardDeadzone && xaxis < forwardDeadzone) xaxis = 0;

	motor[FrontRight]  = -xaxis + yaxis + turning;
	motor[FrontLeft] = xaxis + yaxis + turning;
	motor[RearLeft] = -xaxis - yaxis + turning;
	motor[RearRight] = xaxis - yaxis + turning;
}


void forklift(int up, int down, int armUp)
{
	int speed = 0;
	int semiSpeed = 0;

	if (up && !down)
		speed = 80;

	else if (!up && down)
		speed = -80;

	motor[Fork] = speed;
}
void wincherino(int up, int down)
{
	int speed = 0;

	if (up && !down)
		speed = 127;

	else if (!up && down)
		speed = -127;

	motor[Winch] = speed;
}

void pre_auton()
{
	bStopTasksBetweenModes = true;
}

void driveForward()
{
	drive(127, 0, 0);
	delay(1430);
	drive(0, 0, 0);
	motor[port4] = motor[port5] = motor[port6] = motor[port7] = 127;
	delay(1500);
	motor[port4] = motor[port5] = motor[port6] = motor[port7] = 40;
	//drive forward and knock the stars down
	motor[port2] = motor[port10] = -60;
}

task autonomous()
{
	driveForward();
}

float drTarg = 0.0;
float dlTarg = 0.0;
float aTarg = 0;
float aCTUALaRMvAL;
float sensorVal;
float aErr;
int armPos;
float kpCalc;
float kiCalc;
float kdCalc;
float realArm;
bool julian = false;

bool manual;

float getArm() {
	return SensorValue[armShaft] - sensorVal;
}

task arm()
{
	while (true)
	{
		bool up = vexRT[Btn5U];
		bool down = vexRT[Btn5D];

		//toggles if arm can go past 90 degrees
		//should be renamed but whatever
		//if true, go past 90
		if(vexRT[Btn7U])
		{
			julian = !julian;
			SensorValue[dgtl5] = julian;
		}

		//if you're pressing up button
		if (up && !down)
		{
			manual = true;
			//while you hold up button, the target is set to the max value (depending if it can go past 90 deg)
			while(vexRT[Btn5U] && manual)
			{
				if(julian)
					aTarg = -2600;
				else
					aTarg = -1900;
			}
			//sets the target to the current position
			//(-200 to account for the speed its already going [not necessary, maybe change value])
			aTarg = getArm() - 200;
			manual = false;
		}

		//works the same as the previous block of code but for going down, and sets value to 0 or bottom
		if (!up && down)
		{
			aTarg = 0;
			manual = true;
			while(vexRT[Btn5D] && manual)
			{
			}
			manual = false;
			aTarg = getArm() + 100;
		}

		//probably don't need these, but just to make sure target doesn't go out of bounds, as that would seriously fuck things up
		if(aTarg > 0)
			aTarg = 0;

		if(aTarg < -1900 && !julian)
			aTarg = -1900;
	}
}

//sets the motors
void armPo(int po) {
	motor[LTopArm] = motor[LBotArm] = motor[RTopArm] = motor[RBotArm] = po;
}

//presets for the arm. just sets the target. not much to it.
task armPresets()
{
	while(true)
	{
		aCTUALaRMvAL = getArm();
		bool top = vexRT[Btn8R];
		bool mid = vexRT[Btn8L];

		if(top)
		{
			manual = false;
			aTarg = -1900;
		}

		if(mid)
		{
			manual = false;
			aTarg = -950;
		}
	}
}

//wat
//you do you julian
void stupid(int up, int down)
{
	int speed = 0;

	if (up && !down)
		speed = 127;

	else if (!up && down)
		speed = -127;

	motor[port4] = motor[port5] = motor[port6] = motor[port7] = 127;
}

task armPID() {
	//some pid code that i just copied
	//change values below if it's not working properly

	//change to edit how fast it will move towards the target
	float aKp = .07; //.07
	//change to i dont know (i think to predict when it's getting close and slow down)
	float aKi = .000025; //.000025
	//change to i dont know (related to kp)
	float aKd = .0003; //.0003
	float aInt = 0;
	float aDer = 0;
	float aLErr = 0;
	while(true) {
		aErr = aTarg - getArm();
		realArm = getArm();
		aInt += aErr / 10;
		if (abs(aErr) < 5) {
			aInt = 0;
		}
		aDer = aErr - aLErr;
		aLErr = aErr;
		kpCalc = aKp * aErr;
		kiCalc = aKi * aInt;
		kdCalc = aKd * aDer;
		armPos = (aKp*aErr)+(aKi*aInt)+(aKd*aDer);

		//limits the armpos to 127 and -127 for future calculations
		if(armPos > 127) armPos = 127;
		if(armPos < -127) armPos = -127;

		//based on if you're manually raising/lowering the arm or if it's a preset, it will make it go slower
		if(manual && armPos < 0)
			armPos = (int)(armPos * 0.8);
		else if(manual && armPos > 0)
			armPos = (int)(armPos * 0.6);
		else if(armPos > 0)
			armPos = (int)(armPos * 0.5);

		armPo(-1 * armPos);
	}
}
task temp()
{
	if(vexRT[Btn7L] == true)
	{
		motor[port4] = motor[port5] = motor[port6] = motor[port7] = 127;
	}
	else if(vexRT[Btn7R] == true)
	{
		motor[port4] = motor[port5] = motor[port6] = motor[port7] = -127;
	}
	else
	{
		motor[port4] = motor[port5] = motor[port6] = motor[port7] = 0;
	}
}
task usercontrol()
{
	//starts all the tasks
	sensorVal = SensorValue[armShaft];
	startTask(armPID);
	startTask(arm);
	startTask(armPresets);
	startTask(temp);
	while (true)
	{
		drive(vexRT[Ch3], vexRT[Ch1], vexRT[Ch4]);
		forklift(vexRT[Btn6U], vexRT[Btn6D], vexRT[Btn5U]);
		wincherino(vexRT[Btn8U], vexRT[Btn8D]);
		//stupid(vexRT[Btn7L], vexRT[Btn7R]);

	}
}
